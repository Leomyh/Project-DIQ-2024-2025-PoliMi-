# -*- coding: utf-8 -*-
"""7_Yi_Mao.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bsgi4m-NphDdSu0PsooBQp8vrkHduxtF

#**SetUp**
"""

# Commented out IPython magic to ensure Python compatibility.
from google.colab import drive
drive.mount('/gdrive')
# %cd /gdrive/My Drive/Colab Notebooks/YiMao/DIQ

import sys

pip install thefuzz

!pip install recordlinkage

!pip install ydata-profiling efficient-apriori

"""#**0. Libraries**"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.cluster import DBSCAN
import seaborn as sns
import re

from thefuzz import fuzz
from collections import defaultdict
import recordlinkage # Import necessary module from the recordlinkage library
from ydata_profiling import ProfileReport
import efficient_apriori

"""#**1. Data Profiling**

**import data set**
"""

fifa = pd.read_csv('fifa_original.csv')
fifa

"""**show columns and rows**"""

#column
COL = fifa.columns
COL

#row number
ROW_NUM = len(fifa)
ROW_NUM

"""**shapes**"""

fifa.shape

"""**data types**"""

#numerical
NUM_TYPE = list(fifa.select_dtypes(include=['int64','float64']).columns)
NUM_TYPE

#categorical
CAT_TYPE = list(fifa.select_dtypes(include=['object']).columns)
CAT_TYPE

"""**Description**"""

fifa.describe()

"""**Duplicated**"""

fifa.duplicated().any()

NUM = list(fifa.select_dtypes(include=['int64','float64']).columns)
fifa_NUM = fifa[NUM]
fifa_NUM.corr(method ='pearson')

corr = fifa_NUM.corr(method ='pearson')
sns.heatmap(corr)
plt.show()

PROFILE = ProfileReport(fifa, title="Pandas Profiling Report")
PROFILE

"""# **2. Data Quality Assessment**"""

def print_colored(value, condition):
    if condition:
        print(f"\033[91m{value}\033[0m")  # red
    else:
        print(value)  # black

for col in fifa.columns:
    COUNT = fifa[col].count()
    DISTINCT = fifa[col].nunique()
    ROWS = len(fifa[col])

    NULL = fifa[col].isnull().sum()
    Missing = (fifa[col] == '').sum()

    Actual = fifa[col].dropna()[fifa[col] != ''].count()         # total        non null and non missing value in the row
    Cardinality = fifa[col].dropna()[fifa[col] != ''].nunique()  # total unique non null and non missing value in the row

    UNIQUENESS = Cardinality / ROWS                              # percentage of unique value in the row
    DISTINCTNESS = Cardinality / Actual if Actual else 0         # percentage of unique value in the actual value of row

    Completeness = Actual / ROWS if ROWS else 0                  # percentage of non-NULL value in the row

    print(f"DQ Assessment for {col}:")
    print_colored(f"NULL: {NULL}", NULL != 0)
    print_colored(f"Missing: {Missing}", Missing > 0)
    print_colored(f"Actual: {Actual}", Actual < ROWS)
    print_colored(f"Completeness: {Completeness:.12f}", Completeness != 1)
    print_colored(f"Cardinality: {Cardinality}", Cardinality < 1 or Cardinality < ROWS)
    print_colored(f"Uniqueness: {UNIQUENESS:.12f}", UNIQUENESS != 1)
    print_colored(f"Distinctness: {DISTINCTNESS:.12f}", DISTINCTNESS < UNIQUENESS)
    print("\n")

"""#**3. Data Cleaning**

##**Data Transformation/Standardization**

column: LongName
"""

# check unique values
fifa.LongName.unique()

"""column: Nationality"""

# check unique values
fifa.Nationality.unique()

"""column: Age"""

# check unique values
fifa['Age'].unique()

"""column: ↓OVA"""

# check unique values
fifa['↓OVA'].unique()

"""column: POT"""

# check unique values
fifa['POT'].unique()

"""column: Club"""

# check unique values
fifa['Club'].unique()

# Define a function to clean the Club column
def clean_club(value):
    # Remove \n characters
    cleaned_value = value.replace("\n", "").strip()
    return cleaned_value

# Apply the cleaning function to the Club column
fifa["CleanedClub"] = fifa["Club"].apply(clean_club)

# Replace the original column with the cleaned column
fifa["Club"] = fifa["CleanedClub"]

# Drop the temporary cleaned column using inplace=True to modify the DataFrame directly
fifa.drop(columns=["CleanedClub"], inplace=True)

# Check the result
fifa["Club"].unique()

"""column: Contract"""

# Get unique values from the "Contract" column to examine the data format
fifa.Contract.unique()

# The idea：
# Split "Contract" into three separate columns: Contract Initial, Contract End, and Contract Status.
# Contract Status can be: "Permanent", "On loan", or "Free".
# Example transformations:
# '2004 ~ 2021' -> ("2004", "2021", "Permanent")
# "Jun 30, 2021 On Loan" -> (None, "2021-06-30", "On Loan")
# "Free" -> (None, None, "Free")

# Function to clean the contract information and extract the start year, end year, and contract status
def clean_contract(value):
  # Initialize start_year and end_year to None in case no match is found
  start_year = None
  end_year = None

  #Permanent Contract
  pattern_year_range = r'^(\d{4})\s*~\s*(\d{4})$'
  match_range = re.match(pattern_year_range, value)
  if match_range:
    # Extract the start year and end year
    start_year = match_range.group(1)
    end_year   = match_range.group(2)
    return (start_year, end_year, "Permanent")

  # Loan Contract: Matches "Jun 30, 2021 On Loan"
  pattern_on_loan = r'^(.*\d{4})\s+On Loan$'
  match_loan = re.match(pattern_on_loan, value)
  if match_loan:
      date_part = match_loan.group(1) # Extract the date part like "Jun 30, 2021"
      # Try to convert the date part into a standard format (YYYY-MM-DD)
      try:
            date_obj = pd.to_datetime(date_part)
            date_str = date_obj.strftime('%Y-%m-%d')  # Format the date as "YYYY-MM-DD"
      except:
            # If conversion fails, keep the original date format
            date_str = date_part
      return (date_str, None, "On Loan")

   # Free Contract: Matches "Free"
  if value.strip().lower() == "free":
        return (None, None, "Free")
  # If no pattern matched, return the original value with "Unknown" status
  return (value, None, "Unknown")


# Apply the clean_contract function to the "Contract" column and create a new "CleanedContract" column
fifa["CleanedContract"] = fifa["Contract"].apply(clean_contract)

# Split the "CleanedContract" column into three separate columns: ContractStart, ContractEnd, ContractStatus
fifa[["ContractStart", "ContractEnd", "ContractStatus"]] = (
    fifa["CleanedContract"].apply(lambda x: pd.Series(x))
)

# Drop the intermediate "CleanedContract" and original "Contract" columns, as they are no longer needed
fifa.drop(columns=["CleanedContract"], inplace=True)
fifa.drop(columns=["Contract"], inplace=True)

# Drop the "Loan Date End" column if it is no longer needed after the contract status is processed
fifa.drop(columns=["Loan Date End"], inplace=True)

# Display the first 20 rows to verify the changes
fifa.head(20)

fifa

"""column: Positions"""

# check unique values
fifa['Positions'].unique()

"""column: Height"""

# check unique values
fifa['Height'].unique()

# Remove the 'cm' suffix and convert the values to numeric type
fifa['Height'] = fifa['Height'].str.replace('cm', '').str.strip()

# Check the unique values after the transformation
fifa['Height'].unique()

# Function to convert height from feet and inches to centimeters
def convert_height_to_cm(height):
    # Check if the height is in the 'feet'inches' format (e.g., "5'9")
    match = re.match(r"(\d+)'(\d+)", height)
    if match:
        feet = int(match.group(1))  # Extract the feet part
        inches = int(match.group(2))  # Extract the inches part
        # Convert feet and inches to centimeters and round to the nearest integer
        return int(round(feet * 30.48 + inches * 2.54))
    else:
        # If the height is not in feet-inches format, return the original value
        return height

# Apply the height conversion function to the 'Height' column
fifa['Height'] = fifa['Height'].apply(convert_height_to_cm)

# Convert the 'Height' column to numeric values (in cm), coercing errors to NaN
fifa['Height'] = pd.to_numeric(fifa['Height'], errors='coerce')

fifa.rename(columns={'Height': 'Height(cm)'}, inplace=True)

# Check the unique values after the conversion
fifa['Height(cm)'].unique()

"""column: Weight"""

# check unique values
fifa['Weight'].unique()

# Function to convert weight to kilograms (kg)
def convert_weight_to_kg(weight):
    # Check if the weight is already in kg
    if 'kg' in weight:
        # Remove the 'kg' suffix and convert to integer
        return int(weight.replace('kg', '').strip())

    # Check if the weight is in lbs (pounds)
    elif 'lbs' in weight:
        lbs = int(weight.replace('lbs', '').strip())  # Remove the 'lbs' suffix
        # Convert lbs to kg using the conversion factor (1 lb = 0.453592 kg) and round to the nearest integer
        return int(round(lbs * 0.453592))

    # For unknown formats, return None
    else:
        return None

# Apply the weight conversion function to the 'Weight' column
fifa['Weight'] = fifa['Weight'].apply(convert_weight_to_kg)

fifa.rename(columns={'Weight': 'Weight(kg)'}, inplace=True)

# Check the unique values after the conversion to verify the results
fifa['Weight(kg)'].unique()

"""column: Preferred Foot"""

# check unique values
fifa['Preferred Foot'].unique()

"""column: Best Position"""

# check unique values
fifa['Best Position'].unique()

# Idea:
# We have a list of possible positions that players can play in.
# We will create new columns for each of these positions in the DataFrame.
# Each player will be labeled with 'Best', 'Yes', or 'No' for each position:
# - 'Best' if the position is their Best Position
# - 'Yes' if the player can play that position (based on the Positions column)
# - 'No' if the player cannot play that position.

# List of possible positions
possible_positions = ['RW', 'ST', 'GK', 'CAM', 'LW', 'CB',
                      'CDM', 'CF', 'CM', 'RB', 'LB', 'LM',
                      'RM', 'LWB', 'RWB']

# Function to determine the position label for a given player
def get_position_label(row, pos):
    # If the position is the player's best position, label as 'Best'
    if pos == row['Best Position']:
        return 'Best'
    # If the position is found in the player's "Positions" column, label as 'Yes'
    elif pos in [p.strip() for p in row['Positions'].split(',')]:
        return 'Yes'
    # Otherwise, label as 'No'
    else:
        return 'No'

# Apply the function to all positions and create new columns for each
for pos in possible_positions:
    # Apply `get_position_label` function to each row for the current position
    fifa[pos] = fifa.apply(lambda r: get_position_label(r, pos), axis=1)

# Drop the original columns: Positions and Best Position, as they are no longer needed
fifa = fifa.drop(columns=["Positions"])
fifa = fifa.drop(columns=["Best Position"])

# Display the updated DataFrame to check the results
print(fifa.head())

"""column: Joined"""

# check unique values
fifa['Joined'].unique()

# Convert the Joined column to datetime and format it to YYYY-MM-DD
fifa['Joined'] = pd.to_datetime(fifa['Joined'], format='%b %d, %Y')

# Reformat the datetime column to a string with the format YYYY-MM-DD
fifa['Joined'] = fifa['Joined'].dt.strftime('%Y-%m-%d')

# Display the first 10 rows of the updated Joined column
fifa['Joined'].unique()

"""column: Value"""

# check unique values
fifa['Value'].unique()

# Define the function to clean and convert the Value column
def clean_value(value):
    # Remove the € symbol and strip any extra spaces
    cleaned_value = value.replace('€', '').strip()

    # Check for "M" (millions) and "K" (thousands) and convert to integer
    if 'M' in cleaned_value:
        # Convert millions to thousands, multiply by 1000, and convert to integer
        return int(float(cleaned_value.replace('M', '')) * 1000)
    elif 'K' in cleaned_value:
        # Already in thousands, just convert to float and then to integer
        return int(float(cleaned_value.replace('K', '')))
    else:
        # If no 'M' or 'K', try to convert directly to integer, if not possible, keep as is
        try:
            return int(float(cleaned_value))
        except ValueError:
            return cleaned_value  # Return the original cleaned value if not convertible

# Apply the function to the 'Value' column and create the 'Value(k€)' column
fifa['Value(k€)'] = fifa['Value'].apply(clean_value)

# Drop the original 'Value' column
fifa.drop(columns=['Value'], inplace=True)

# Convert 'Value(k€)' to integers directly, NaN will be handled as 'NaN' in the DataFrame
fifa['Value(k€)'] = fifa['Value(k€)'].astype('Int64')  # 'Int64' allows for nullable integers

# Check the unique values in the 'Value(k€)' column after the conversion
fifa['Value(k€)'].unique()

"""column: Wage"""

# check unique values
fifa['Wage'].unique()

# Define a function to clean and convert the Wage column
def clean_wage(value):
    # Remove the € symbol and strip any extra spaces
    cleaned_value = value.replace('€', '').strip()

    # Check for "K" (thousands) and "M" (millions) and convert to thousands
    if 'K' in cleaned_value:
        # Return the value as an integer (already in thousands)
        return int(float(cleaned_value.replace('K', '')) * 1000)
    else:
        # If no 'M' or 'K', try to convert directly to integer, if not possible, keep as is
        try:
            return int(float(cleaned_value))
        except ValueError:
            return cleaned_value  # Return the original cleaned value if not convertible


# Apply the function to the Wage column and create a new column "Wage(K€)"
fifa['Wage(€)'] = fifa['Wage'].apply(clean_wage)

# Drop the original Wage column
fifa.drop(columns=['Wage'], inplace=True)

# Ensure the 'Wage(K€)' column is of integer type
fifa['Wage(€)'] = fifa['Wage(€)'].astype('Int64')  # 'Int64' allows nullable integers

# Check the unique values in the 'Wage(K€)' column after conversion
fifa['Wage(€)'].unique()

"""column: Release Clause"""

# check unique values
fifa['Release Clause'].unique()

# Define a function to clean and convert the Release Clause column
def clean_release_clause(value):
    # Remove the € symbol and strip any extra spaces
    cleaned_value = value.replace('€', '').strip()

    # Check for "M" (millions) and "K" (thousands) and handle accordingly
    if 'M' in cleaned_value:
        # Convert millions to thousands, multiply by 1000, and return as integer
        return int(float(cleaned_value.replace('M', '')) * 1000)
    elif 'K' in cleaned_value:
        # Already in thousands, just convert to float and then to integer
        return int(float(cleaned_value.replace('K', '')))
    else:
        # If no 'M' or 'K', try to convert directly to integer, if not possible, keep as is
        try:
            return int(float(cleaned_value))
        except ValueError:
            return cleaned_value  # Return the original cleaned value if not convertible

# Apply the function to the Release Clause column and create a new column "Release Clause (k€)"
fifa['Release Clause(k€)'] = fifa['Release Clause'].apply(clean_release_clause)

# Drop the original Release Clause column
fifa.drop(columns=['Release Clause'], inplace=True)

# Ensure the 'Release Clause (k€)' column is of integer type
fifa['Release Clause(k€)'] = fifa['Release Clause(k€)'].astype('Int64')  # 'Int64' allows nullable integers

# Check the unique values in the 'Release Clause (k€)' column after conversion
fifa['Release Clause(k€)'].unique()

"""column: Attacking = Crossing + Finishing + Heading + Accuracy + Short Passing + Volleys

column: Skill = Dribbling + Curve + FK Accuracy + Long Passing + Ball Control

column: Movement = Acceleration + Sprint Speed + Agility + Reactions + Balance

column: Power = Shot Power + Jumping + Stamina + Strength + Long Shots

column: Mentality = Aggression + Interceptions + Positioning + Vision + Penalties + Composure

column: Defending = Marking + Standing Tackle + Sliding Tackle

column: Goalkeeping = GK Diving + GK Handling + GK Kicking + GK Positioning + GK Reflexes

column: Total Stats = Attacking + Skill + Movement + Power + Mentality + Defending + Goalkeeping

column: Base Stats = PAC + SHO + PAS + DRI + DEF + PHY

column: W/F
"""

# check unique values
fifa['W/F'].unique()

# Define a function to clean the W/F column
def clean_wf(value):
    # Remove the "★" symbol and convert to integer
    cleaned_value = value.replace('★', '').strip()
    return int(cleaned_value)

# Apply the function to the W/F column
fifa['W/F'] = fifa['W/F'].apply(clean_wf)

# Display
fifa['W/F'].unique()

"""column: SM"""

# check unique values
fifa['SM'].unique()

# Define a function to clean the SM column
def clean_sm(value):
    # Remove the "★" symbol and convert to integer
    cleaned_value = value.replace('★', '').strip()
    return int(cleaned_value)

# Apply the function to the SM column
fifa['SM'] = fifa['SM'].apply(clean_sm)

fifa['SM'].unique()

"""column: A/W"""

# check unique values
fifa['A/W'].unique()

"""column: D/W"""

# check unique values
fifa['D/W'].unique()

"""column: IR"""

# check unique values
fifa['IR'].unique()

# Define a function to clean the IR column
def clean_ir(value):
    # Remove the "★" symbol and convert to integer
    cleaned_value = value.replace('★', '').strip()
    return int(cleaned_value)

# Apply the function to the IR column
fifa['IR'] = fifa['IR'].apply(clean_ir)

fifa['IR'].unique()

"""column: Hits"""

# check unique values
fifa['Hits'].unique()

# Conversion function
def convert_hits_to_integer(value):
    # Check if the value is NaN, if so, return NaN
    if pd.isna(value):
        return np.nan

    # Convert the value to a string, strip leading/trailing spaces, and make it lowercase
    value = str(value).strip().lower()

    # Check if the value contains 'k' (thousands)
    if 'k' in value:
        # Remove 'k', convert to float, multiply by 1000, and then convert to integer
        return int(float(value.replace('k', '')) * 1000)
    else:
        try:
            # Try to convert the value to an integer (if it's a regular number)
            return int(float(value))
        except ValueError:
            # If conversion fails (for invalid values), return NaN
            return np.nan

# Apply the conversion function to the 'Hits' column
fifa['Hits'] = fifa['Hits'].apply(convert_hits_to_integer)

# Convert the column to int64
fifa['Hits'] = fifa['Hits'].astype('Int64')

# Check the unique values in the 'Hits' column after conversion
print(fifa['Hits'].unique())

"""**Final steps cleaned**"""

fifa

"""##**Error Detection and Correction Missing Values**"""

# Initialize an empty list to store information about missing data
missing_data_info = []

# Check all missing values columns
for col in fifa.columns:
    # Calculate the number of NaN values in the column
    null_count = fifa[col].isnull().sum()
    # Calculate the number of empty strings in the column
    empty_string_count = (fifa[col] == '').sum()

    # Add information to list if there are any missing values or empty strings
    if null_count > 0 or empty_string_count > 0:
        missing_data_info.append({
            'Column': col,
            'Null Values': null_count,
            'Empty Strings': empty_string_count
        })

# Convert the list to a DataFrame for better readability
missing_data_df = pd.DataFrame(missing_data_info)

# Display the DataFrame
print(missing_data_df)

# Correct approach to avoid the FutureWarning:
# Set missing 'Hits' to zero
fifa['Hits'] = fifa['Hits'].fillna(0)

# Set missing 'ContractStart' and 'ContractEnd' to 'Unknown'
fifa['ContractStart'] = fifa['ContractStart'].fillna('Unknown')
fifa['ContractEnd'] = fifa['ContractEnd'].fillna('Unknown')

fifa

fifa.isnull().sum()

"""##**Error Detection and Correction Outliers**

Dropped columns:
> Name, Positions, Best Position, Contract, Loan Date End

Added columns:
>  'RW', 'ST', 'GK', 'CAM', 'LW', 'CB', 'CDM', 'CF', 'CM', 'RB', 'LB',
      'LM', 'RM', 'LWB', 'RWB', ContractStart, ContractEnd, ContractStatus

Renamed columns:
> Height -> Height(cm)

> Weight -> Weight(kg)

> Value -> Value(k€)

> Wage -> Wage(€)

> Release Clause-> Release Clause(k€)
"""

df = fifa.copy()

"""column: ↓OVA"""

x = '↓OVA'


# boxplot
print("\nThis is BOX PLOT\n")
plt.boxplot(df[x])
plt.title(x + ' Outlier Detection')
plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")
#IQR
# which Coloumn
column = df[x]

# IQR
Q1 = column.quantile(0.25)
Q3 = column.quantile(0.75)
IQR = Q3 - Q1

# Bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# outliers
outliers = df[(column < lower_bound) | (column > upper_bound)]

print(outliers[['ID', 'LongName', x]])

"""column: POT"""

x = 'POT'

# boxplot
print("\nThis is BOX PLOT\n")
plt.boxplot(df[x])
plt.title(x + ' Outlier Detection')
plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")
#IQR
# which Coloumn
column = df[x]

# IQR
Q1 = column.quantile(0.25)
Q3 = column.quantile(0.75)
IQR = Q3 - Q1

# Bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# outliers
outliers = df[(column < lower_bound) | (column > upper_bound)]

print(outliers[['ID', 'LongName', x]])

"""column: Height"""

df['Height(cm)']

x = 'Height(cm)'

# boxplot
print("\nThis is BOX PLOT\n")
plt.boxplot(df[x])
plt.title(x + ' Outlier Detection')
plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")
#IQR
# which Coloumn
column = df[x]

# IQR
Q1 = column.quantile(0.25)
Q3 = column.quantile(0.75)
IQR = Q3 - Q1

# Bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# outliers
outliers = df[(column < lower_bound) | (column > upper_bound)]

print(outliers[['ID', 'LongName', x]])

"""column: Weight"""

x = 'Weight(kg)'

# boxplot
print("\nThis is BOX PLOT\n")
plt.boxplot(df[x])
plt.title(x + ' Outlier Detection')
plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")
#IQR
# which Coloumn
column = df[x]

# IQR
Q1 = column.quantile(0.25)
Q3 = column.quantile(0.75)
IQR = Q3 - Q1

# Bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# outliers
outliers = df[(column < lower_bound) | (column > upper_bound)]

print(outliers[['ID', 'LongName', x]])

"""column: BOV"""

x = 'BOV'

# boxplot
print("\nThis is BOX PLOT\n")
plt.boxplot(df[x])
plt.title(x + ' Outlier Detection')
plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")
#IQR
# which Coloumn
column = df[x]

# IQR
Q1 = column.quantile(0.25)
Q3 = column.quantile(0.75)
IQR = Q3 - Q1

# Bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# outliers
outliers = df[(column < lower_bound) | (column > upper_bound)]

print(outliers[['ID', 'LongName', x]])

"""column:  Value(k€)"""

x = 'Value(k€)'

# # boxplot
# print("\nThis is BOX PLOT\n")
# plt.boxplot(df[x])
# plt.title(x + ' Outlier Detection')
# plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")
#IQR
# which Coloumn
column = df[x]

# IQR
Q1 = column.quantile(0.25)
Q3 = column.quantile(0.75)
IQR = Q3 - Q1

# Bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# outliers
outliers = df[(column < lower_bound) | (column > upper_bound)]

print(outliers[['ID', 'LongName', x]])

"""column: Wage"""

x = 'Wage(€)'

# # boxplot
# print("\nThis is BOX PLOT\n")
# plt.boxplot(df[x])
# plt.title(x + ' Outlier Detection')
# plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")
#IQR
# which Coloumn
column = df[x]

# IQR
Q1 = column.quantile(0.25)
Q3 = column.quantile(0.75)
IQR = Q3 - Q1

# Bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# outliers
outliers = df[(column < lower_bound) | (column > upper_bound)]

print(outliers[['ID', 'LongName', x]])

"""column: Release Clause"""

x = 'Release Clause(k€)'

# # boxplot
# print("\nThis is BOX PLOT\n")
# plt.boxplot(df[x])
# plt.title(x + ' Outlier Detection')
# plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")
#IQR
# which Coloumn
column = df[x]

# IQR
Q1 = column.quantile(0.25)
Q3 = column.quantile(0.75)
IQR = Q3 - Q1

# Bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# outliers
outliers = df[(column < lower_bound) | (column > upper_bound)]

print(outliers[['ID', 'LongName', x]])

"""column: Attacking"""

x = 'Attacking'

# boxplot
print("\nThis is BOX PLOT\n")
plt.boxplot(df[x])
plt.title(x + ' Outlier Detection')
plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")
#IQR
# which Coloumn
column = df[x]

# IQR
Q1 = column.quantile(0.25)
Q3 = column.quantile(0.75)
IQR = Q3 - Q1

# Bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# outliers
outliers = df[(column < lower_bound) | (column > upper_bound)]

print(outliers[['ID', 'LongName', x]])

"""column: Crossing"""

x = 'Crossing'

# boxplot
print("\nThis is BOX PLOT\n")
plt.boxplot(df[x])
plt.title(x + ' Outlier Detection')
plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")
#IQR
# which Coloumn
column = df[x]

# IQR
Q1 = column.quantile(0.25)
Q3 = column.quantile(0.75)
IQR = Q3 - Q1

# Bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# outliers
outliers = df[(column < lower_bound) | (column > upper_bound)]

print(outliers[['ID', 'LongName', x]])

"""column: Finishing"""

x = 'Finishing'

# boxplot
print("\nThis is BOX PLOT\n")
plt.boxplot(df[x])
plt.title(x + ' Outlier Detection')
plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")
#IQR
# which Coloumn
column = df[x]

# IQR
Q1 = column.quantile(0.25)
Q3 = column.quantile(0.75)
IQR = Q3 - Q1

# Bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# outliers
outliers = df[(column < lower_bound) | (column > upper_bound)]

print(outliers[['ID', 'LongName', x]])

"""column: Heading Accuracy"""

x = 'Heading Accuracy'

# boxplot
print("\nThis is BOX PLOT\n")
plt.boxplot(df[x])
plt.title(x + ' Outlier Detection')
plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")
#IQR
# which Coloumn
column = df[x]

# IQR
Q1 = column.quantile(0.25)
Q3 = column.quantile(0.75)
IQR = Q3 - Q1

# Bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# outliers
outliers = df[(column < lower_bound) | (column > upper_bound)]

print(outliers[['ID', 'LongName', x]])

"""column: Short Passing"""

x = 'Short Passing'

# boxplot
print("\nThis is BOX PLOT\n")
plt.boxplot(df[x])
plt.title(x + ' Outlier Detection')
plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")
#IQR
# which Coloumn
column = df[x]

# IQR
Q1 = column.quantile(0.25)
Q3 = column.quantile(0.75)
IQR = Q3 - Q1

# Bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# outliers
outliers = df[(column < lower_bound) | (column > upper_bound)]

print(outliers[['ID', 'LongName', x]])

"""column: Volleys"""

x = 'Volleys'

# boxplot
print("\nThis is BOX PLOT\n")
plt.boxplot(df[x])
plt.title(x + ' Outlier Detection')
plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")
#IQR
# which Coloumn
column = df[x]

# IQR
Q1 = column.quantile(0.25)
Q3 = column.quantile(0.75)
IQR = Q3 - Q1

# Bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# outliers
outliers = df[(column < lower_bound) | (column > upper_bound)]

print(outliers[['ID', 'LongName', x]])

"""column: Skill"""

x = 'Skill'

# boxplot
print("\nThis is BOX PLOT\n")
plt.boxplot(df[x])
plt.title(x + ' Outlier Detection')
plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")
#IQR
# which Coloumn
column = df[x]

# IQR
Q1 = column.quantile(0.25)
Q3 = column.quantile(0.75)
IQR = Q3 - Q1

# Bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# outliers
outliers = df[(column < lower_bound) | (column > upper_bound)]

print(outliers[['ID', 'LongName', x]])

"""column: Dribbling"""

x = 'Dribbling'

# boxplot
print("\nThis is BOX PLOT\n")
plt.boxplot(df[x])
plt.title(x + ' Outlier Detection')
plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")
#IQR
# which Coloumn
column = df[x]

# IQR
Q1 = column.quantile(0.25)
Q3 = column.quantile(0.75)
IQR = Q3 - Q1

# Bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# outliers
outliers = df[(column < lower_bound) | (column > upper_bound)]

print(outliers[['ID', 'LongName', x]])

plt.hist(df['Dribbling'], bins=20, edgecolor='k', alpha=0.7)
plt.title("Distribution of Dribbling")
plt.xlabel("Dribbling")
plt.ylabel("Frequency")
plt.show()

"""column: Curve"""

x = 'Curve'

# boxplot
print("\nThis is BOX PLOT\n")
plt.boxplot(df[x])
plt.title(x + ' Outlier Detection')
plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")
#IQR
# which Coloumn
column = df[x]

# IQR
Q1 = column.quantile(0.25)
Q3 = column.quantile(0.75)
IQR = Q3 - Q1

# Bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# outliers
outliers = df[(column < lower_bound) | (column > upper_bound)]

print(outliers[['ID', 'LongName', x]])

"""column: FK Accuracy"""

x = 'FK Accuracy'

# boxplot
print("\nThis is BOX PLOT\n")
plt.boxplot(df[x])
plt.title(x + ' Outlier Detection')
plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")
#IQR
# which Coloumn
column = df[x]

# IQR
Q1 = column.quantile(0.25)
Q3 = column.quantile(0.75)
IQR = Q3 - Q1

# Bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# outliers
outliers = df[(column < lower_bound) | (column > upper_bound)]

print(outliers[['ID', 'LongName', x]])

"""column: Long Passing"""

x = 'Long Passing'

# boxplot
print("\nThis is BOX PLOT\n")
plt.boxplot(df[x])
plt.title(x + ' Outlier Detection')
plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")
#IQR
# which Coloumn
column = df[x]

# IQR
Q1 = column.quantile(0.25)
Q3 = column.quantile(0.75)
IQR = Q3 - Q1

# Bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# outliers
outliers = df[(column < lower_bound) | (column > upper_bound)]

print(outliers[['ID', 'LongName', x]])

"""column: Ball Control"""

x = 'Ball Control'

# boxplot
print("\nThis is BOX PLOT\n")
plt.boxplot(df[x])
plt.title(x + ' Outlier Detection')
plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")
#IQR
# which Coloumn
column = df[x]

# IQR
Q1 = column.quantile(0.25)
Q3 = column.quantile(0.75)
IQR = Q3 - Q1

# Bounds
lower_bound = Q1 - 3.0 * IQR
upper_bound = Q3 + 2.5 * IQR

# outliers
outliers = df[(column < lower_bound) | (column > upper_bound)]

print(outliers[['ID', 'LongName', x]])

"""column: Movement"""

x = 'Movement'

# boxplot
print("\nThis is BOX PLOT\n")
plt.boxplot(df[x])
plt.title(x + ' Outlier Detection')
plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")
#IQR
# which Coloumn
column = df[x]

# IQR
Q1 = column.quantile(0.25)
Q3 = column.quantile(0.75)
IQR = Q3 - Q1

# Bounds
lower_bound = Q1 - 2.0 * IQR
upper_bound = Q3 + 2.0 * IQR

# outliers
outliers = df[(column < lower_bound) | (column > upper_bound)]

print(outliers[['ID', 'LongName', x]])

"""column: Acceleration"""

x = 'Acceleration'

# boxplot
print("\nThis is BOX PLOT\n")
plt.boxplot(df[x])
plt.title(x + ' Outlier Detection')
plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")
#IQR
# which Coloumn
column = df[x]

# IQR
Q1 = column.quantile(0.25)
Q3 = column.quantile(0.75)
IQR = Q3 - Q1

# Bounds
lower_bound = Q1 - 2.5 * IQR
upper_bound = Q3 + 2.0 * IQR

# outliers
outliers = df[(column < lower_bound) | (column > upper_bound)]

print(outliers[['ID', 'LongName', x]])

"""column: Sprint Speed"""

x = 'Sprint Speed'

# boxplot
print("\nThis is BOX PLOT\n")
plt.boxplot(df[x])
plt.title(x + ' Outlier Detection')
plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")
#IQR
# which Coloumn
column = df[x]

# IQR
Q1 = column.quantile(0.25)
Q3 = column.quantile(0.75)
IQR = Q3 - Q1

# Bounds
lower_bound = Q1 - 2.5 * IQR
upper_bound = Q3 + 2.0 * IQR

# outliers
outliers = df[(column < lower_bound) | (column > upper_bound)]

print(outliers[['ID', 'LongName', x]])

"""column: Agility"""

x = 'Agility'

# boxplot
print("\nThis is BOX PLOT\n")
plt.boxplot(df[x])
plt.title(x + ' Outlier Detection')
plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")
#IQR
# which Coloumn
column = df[x]

# IQR
Q1 = column.quantile(0.25)
Q3 = column.quantile(0.75)
IQR = Q3 - Q1

# Bounds
lower_bound = Q1 - 2.5 * IQR
upper_bound = Q3 + 2.0 * IQR

# outliers
outliers = df[(column < lower_bound) | (column > upper_bound)]

print(outliers[['ID', 'LongName', x]])

"""column: Reactions"""

x = 'Reactions'

# boxplot
print("\nThis is BOX PLOT\n")
plt.boxplot(df[x])
plt.title(x + ' Outlier Detection')
plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")
#IQR
# which Coloumn
column = df[x]

# IQR
Q1 = column.quantile(0.25)
Q3 = column.quantile(0.75)
IQR = Q3 - Q1

# Bounds
lower_bound = Q1 - 2.5 * IQR
upper_bound = Q3 + 2.0 * IQR

# outliers
outliers = df[(column < lower_bound) | (column > upper_bound)]

print(outliers[['ID', 'LongName', x]])

"""column: Balance"""

x = 'Balance'

# boxplot
print("\nThis is BOX PLOT\n")
plt.boxplot(df[x])
plt.title(x + ' Outlier Detection')
plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")
#IQR
# which Coloumn
column = df[x]

# IQR
Q1 = column.quantile(0.25)
Q3 = column.quantile(0.75)
IQR = Q3 - Q1

# Bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 2.0 * IQR

# outliers
outliers = df[(column < lower_bound) | (column > upper_bound)]

print(outliers[['ID', 'LongName', x]])

"""column: Power"""

x = 'Power'

# boxplot
print("\nThis is BOX PLOT\n")
plt.boxplot(df[x])
plt.title(x + ' Outlier Detection')
plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")
#IQR
# which Coloumn
column = df[x]

# IQR
Q1 = column.quantile(0.25)
Q3 = column.quantile(0.75)
IQR = Q3 - Q1

# Bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# outliers
outliers = df[(column < lower_bound) | (column > upper_bound)]

print(outliers[['ID', 'LongName', x]])

"""column: Shot Power"""

x = 'Shot Power'

# boxplot
print("\nThis is BOX PLOT\n")
plt.boxplot(df[x])
plt.title(x + ' Outlier Detection')
plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")
#IQR
# which Coloumn
column = df[x]

# IQR
Q1 = column.quantile(0.25)
Q3 = column.quantile(0.75)
IQR = Q3 - Q1

# Bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# outliers
outliers = df[(column < lower_bound) | (column > upper_bound)]

print(outliers[['ID', 'LongName', x]])

"""column: Jumping"""

x = 'Jumping'

# boxplot
print("\nThis is BOX PLOT\n")
plt.boxplot(df[x])
plt.title(x + ' Outlier Detection')
plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")
#IQR
# which Coloumn
column = df[x]

# IQR
Q1 = column.quantile(0.25)
Q3 = column.quantile(0.75)
IQR = Q3 - Q1

# Bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# outliers
outliers = df[(column < lower_bound) | (column > upper_bound)]

print(outliers[['ID', 'LongName', x]])

"""column: Stamina"""

x = 'Stamina'

# boxplot
print("\nThis is BOX PLOT\n")
plt.boxplot(df[x])
plt.title(x + ' Outlier Detection')
plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")
#IQR
# which Coloumn
column = df[x]

# IQR
Q1 = column.quantile(0.25)
Q3 = column.quantile(0.75)
IQR = Q3 - Q1

# Bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# outliers
outliers = df[(column < lower_bound) | (column > upper_bound)]

print(outliers[['ID', 'LongName', x]])

"""column: Strength"""

x = 'Strength'

# boxplot
print("\nThis is BOX PLOT\n")
plt.boxplot(df[x])
plt.title(x + ' Outlier Detection')
plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")
#IQR
# which Coloumn
column = df[x]

# IQR
Q1 = column.quantile(0.25)
Q3 = column.quantile(0.75)
IQR = Q3 - Q1

# Bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# outliers
outliers = df[(column < lower_bound) | (column > upper_bound)]

print(outliers[['ID', 'LongName', x]])

"""column: Long Shots"""

x = 'Long Shots'

# boxplot
print("\nThis is BOX PLOT\n")
plt.boxplot(df[x])
plt.title(x + ' Outlier Detection')
plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")
#IQR
# which Coloumn
column = df[x]

# IQR
Q1 = column.quantile(0.25)
Q3 = column.quantile(0.75)
IQR = Q3 - Q1

# Bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# outliers
outliers = df[(column < lower_bound) | (column > upper_bound)]

print(outliers[['ID', 'LongName', x]])

"""column: Mentality"""

x = 'Mentality'

# boxplot
print("\nThis is BOX PLOT\n")
plt.boxplot(df[x])
plt.title(x + ' Outlier Detection')
plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")
#IQR
# which Coloumn
column = df[x]

# IQR
Q1 = column.quantile(0.25)
Q3 = column.quantile(0.75)
IQR = Q3 - Q1

# Bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# outliers
outliers = df[(column < lower_bound) | (column > upper_bound)]

print(outliers[['ID', 'LongName', x]])

"""column: Aggression"""

x = 'Aggression'

# boxplot
print("\nThis is BOX PLOT\n")
plt.boxplot(df[x])
plt.title(x + ' Outlier Detection')
plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")
#IQR
# which Coloumn
column = df[x]

# IQR
Q1 = column.quantile(0.25)
Q3 = column.quantile(0.75)
IQR = Q3 - Q1

# Bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# outliers
outliers = df[(column < lower_bound) | (column > upper_bound)]

print(outliers[['ID', 'LongName', x]])

"""column: Interceptions"""

x = 'Interceptions'

# boxplot
print("\nThis is BOX PLOT\n")
plt.boxplot(df[x])
plt.title(x + ' Outlier Detection')
plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")
#IQR
# which Coloumn
column = df[x]

# IQR
Q1 = column.quantile(0.25)
Q3 = column.quantile(0.75)
IQR = Q3 - Q1

# Bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# outliers
outliers = df[(column < lower_bound) | (column > upper_bound)]

print(outliers[['ID', 'LongName', x]])

"""column: Positioning"""

x = 'Positioning'

# boxplot
print("\nThis is BOX PLOT\n")
plt.boxplot(df[x])
plt.title(x + ' Outlier Detection')
plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")
#IQR
# which Coloumn
column = df[x]

# IQR
Q1 = column.quantile(0.25)
Q3 = column.quantile(0.75)
IQR = Q3 - Q1

# Bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# outliers
outliers = df[(column < lower_bound) | (column > upper_bound)]

print(outliers[['ID', 'LongName', x]])

"""column: Vision"""

x = 'Vision'

# boxplot
print("\nThis is BOX PLOT\n")
plt.boxplot(df[x])
plt.title(x + ' Outlier Detection')
plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")
#IQR
# which Coloumn
column = df[x]

# IQR
Q1 = column.quantile(0.25)
Q3 = column.quantile(0.75)
IQR = Q3 - Q1

# Bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# outliers
outliers = df[(column < lower_bound) | (column > upper_bound)]

print(outliers[['ID', 'LongName', x]])

"""column: Penalties"""

x = 'Penalties'

# boxplot
print("\nThis is BOX PLOT\n")
plt.boxplot(df[x])
plt.title(x + ' Outlier Detection')
plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")
#IQR
# which Coloumn
column = df[x]

# IQR
Q1 = column.quantile(0.25)
Q3 = column.quantile(0.75)
IQR = Q3 - Q1

# Bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# outliers
outliers = df[(column < lower_bound) | (column > upper_bound)]

print(outliers[['ID', 'LongName', x]])

"""column: Composure"""

x = 'Composure'

# boxplot
print("\nThis is BOX PLOT\n")
plt.boxplot(df[x])
plt.title(x + ' Outlier Detection')
plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(fifa[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")
#IQR
# which Coloumn
column = df[x]

# IQR
Q1 = column.quantile(0.25)
Q3 = column.quantile(0.75)
IQR = Q3 - Q1

# Bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# outliers
outliers = df[(column < lower_bound) | (column > upper_bound)]

print(outliers[['ID', 'LongName', x]])

"""column: Defending"""

x = 'Defending'

# boxplot
print("\nThis is BOX PLOT\n")
plt.boxplot(df[x])
plt.title(x + ' Outlier Detection')
plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")
#IQR
# which Coloumn
column = df[x]

# IQR
Q1 = column.quantile(0.25)
Q3 = column.quantile(0.75)
IQR = Q3 - Q1

# Bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# outliers
outliers = df[(column < lower_bound) | (column > upper_bound)]

print(outliers[['ID', 'LongName', x]])

"""column: Marking"""

x = 'Marking'

# boxplot
print("\nThis is BOX PLOT\n")
plt.boxplot(df[x])
plt.title(x + ' Outlier Detection')
plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")
#IQR
# which Coloumn
column = df[x]

# IQR
Q1 = column.quantile(0.25)
Q3 = column.quantile(0.75)
IQR = Q3 - Q1

# Bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# outliers
outliers = df[(column < lower_bound) | (column > upper_bound)]

print(outliers[['ID', 'LongName', x]])

"""column: Standing Tackle"""

x = 'Standing Tackle'

# boxplot
print("\nThis is BOX PLOT\n")
plt.boxplot(df[x])
plt.title(x + ' Outlier Detection')
plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")
#IQR
# which Coloumn
column = df[x]

# IQR
Q1 = column.quantile(0.25)
Q3 = column.quantile(0.75)
IQR = Q3 - Q1

# Bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# outliers
outliers = df[(column < lower_bound) | (column > upper_bound)]

print(outliers[['ID', 'LongName', x]])

"""column: Sliding Tackle"""

x = 'Sliding Tackle'

# boxplot
print("\nThis is BOX PLOT\n")
plt.boxplot(df[x])
plt.title(x + ' Outlier Detection')
plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")
#IQR
# which Coloumn
column = df[x]

# IQR
Q1 = column.quantile(0.25)
Q3 = column.quantile(0.75)
IQR = Q3 - Q1

# Bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# outliers
outliers = df[(column < lower_bound) | (column > upper_bound)]

print(outliers[['ID', 'LongName', x]])

"""column: Goalkeeping"""

x = 'Goalkeeping'

# boxplot
print("\nThis is BOX PLOT\n")
plt.boxplot(df[x])
plt.title(x + ' Outlier Detection')
plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")
# #IQR
# # which Coloumn
# column = df[x]

# # IQR
# Q1 = column.quantile(0.25)
# Q3 = column.quantile(0.75)
# IQR = Q3 - Q1

# # Bounds
# lower_bound = Q1 - 1.5 * IQR
# upper_bound = Q3 + 1.5 * IQR

# # outliers
# outliers = df[(column < lower_bound) | (column > upper_bound)]

# print(outliers[['ID', 'LongName', x]])

"""column: GK Diving"""

x = 'GK Diving'

# boxplot
print("\nThis is BOX PLOT\n")
plt.boxplot(df[x])
plt.title(x + ' Outlier Detection')
plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")
# #IQR
# # which Coloumn
# column = df[x]

# # IQR
# Q1 = column.quantile(0.25)
# Q3 = column.quantile(0.75)
# IQR = Q3 - Q1

# # Bounds
# lower_bound = Q1 - 1.5 * IQR
# upper_bound = Q3 + 1.5 * IQR

# # outliers
# outliers = df[(column < lower_bound) | (column > upper_bound)]

# print(outliers[['ID', 'LongName', x]])

"""column: GK Handling"""

x = 'GK Handling'

# boxplot
print("\nThis is BOX PLOT\n")
plt.boxplot(df[x])
plt.title(x + ' Outlier Detection')
plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")
#IQR
# which Coloumn
column = df[x]

# # IQR
# Q1 = column.quantile(0.25)
# Q3 = column.quantile(0.75)
# IQR = Q3 - Q1

# # Bounds
# lower_bound = Q1 - 1.5 * IQR
# upper_bound = Q3 + 1.5 * IQR

# # outliers
# outliers = df[(column < lower_bound) | (column > upper_bound)]

# print(outliers[['ID', 'LongName', x]])

"""column: GK Kicking"""

x = 'GK Kicking'

# boxplot
print("\nThis is BOX PLOT\n")
plt.boxplot(df[x])
plt.title(x + ' Outlier Detection')
plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")
# #IQR
# # which Coloumn
# column = df[x]

# # IQR
# Q1 = column.quantile(0.25)
# Q3 = column.quantile(0.75)
# IQR = Q3 - Q1

# # Bounds
# lower_bound = Q1 - 1.5 * IQR
# upper_bound = Q3 + 1.5 * IQR

# # outliers
# outliers = df[(column < lower_bound) | (column > upper_bound)]

# print(outliers[['ID', 'LongName', x]])

"""column: GK Positioning"""

x = 'GK Positioning'

# boxplot
print("\nThis is BOX PLOT\n")
plt.boxplot(df[x])
plt.title(x + ' Outlier Detection')
plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")
# #IQR
# # which Coloumn
# column = df[x]

# # IQR
# Q1 = column.quantile(0.25)
# Q3 = column.quantile(0.75)
# IQR = Q3 - Q1

# # Bounds
# lower_bound = Q1 - 1.5 * IQR
# upper_bound = Q3 + 1.5 * IQR

# # outliers
# outliers = df[(column < lower_bound) | (column > upper_bound)]

# print(outliers[['ID', 'LongName', x]])

"""column: GK Reflexes"""

x = 'GK Reflexes'

# boxplot
print("\nThis is BOX PLOT\n")
plt.boxplot(df[x])
plt.title(x + ' Outlier Detection')
plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")

# #IQR
# # which Coloumn
# column = df[x]

# # IQR
# Q1 = column.quantile(0.25)
# Q3 = column.quantile(0.75)
# IQR = Q3 - Q1

# # Bounds
# lower_bound = Q1 - 1.5 * IQR
# upper_bound = Q3 + 1.5 * IQR

# # outliers
# outliers = df[(column < lower_bound) | (column > upper_bound)]

# print(outliers[['ID', 'LongName', x]])

"""column: Total Stats"""

x = 'Total Stats'

# boxplot
print("\nThis is BOX PLOT\n")
plt.boxplot(df[x])
plt.title(x + ' Outlier Detection')
plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")
#IQR
# which Coloumn
column = df[x]

# IQR
Q1 = column.quantile(0.25)
Q3 = column.quantile(0.75)
IQR = Q3 - Q1

# Bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# outliers
outliers = df[(column < lower_bound) | (column > upper_bound)]

print(outliers[['ID', 'LongName', x]])

"""column: Base Stats"""

x = 'Base Stats'

# boxplot
print("\nThis is BOX PLOT\n")
plt.boxplot(df[x])
plt.title(x + ' Outlier Detection')
plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")
#IQR
# which Coloumn
column = df[x]

# IQR
Q1 = column.quantile(0.25)
Q3 = column.quantile(0.75)
IQR = Q3 - Q1

# Bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# outliers
outliers = df[(column < lower_bound) | (column > upper_bound)]

print(outliers[['ID', 'LongName', x]])

"""column: W/F"""

x = 'W/F'

counts = df[x].value_counts()

# Plot
sns.barplot(x=counts.index, y=counts.values)
plt.title(x+' Distribution')
plt.xlabel(x+' Rating')
plt.ylabel('Number of Players')
plt.show()

"""column: SM"""

x = 'SM'

counts = df[x].value_counts()
# Plot
sns.barplot(x=counts.index, y=counts.values)
plt.title(x+' Distribution')
plt.xlabel(x+' Rating')
plt.ylabel('Number of Players')
plt.show()

"""column: A/W"""

x = 'A/W'

counts = df[x].value_counts()

# Plot
sns.barplot(x=counts.index, y=counts.values)
plt.title(x+' Distribution')
plt.xlabel(x+' Rating')
plt.ylabel('Number of Players')
plt.show()

"""column: D/W"""

x = 'D/W'

counts = df[x].value_counts()

# Plot
sns.barplot(x=counts.index, y=counts.values)
plt.title(x+' Distribution')
plt.xlabel(x+' Rating')
plt.ylabel('Number of Players')
plt.show()

"""column: IR"""

x = 'IR'

counts = df[x].value_counts()

# Plot
sns.barplot(x=counts.index, y=counts.values)
plt.title(x+' Distribution')
plt.xlabel(x+' Rating')
plt.ylabel('Number of Players')
plt.show()

"""column: PAC"""

x = 'PAC'

# boxplot
print("\nThis is BOX PLOT\n")
plt.boxplot(df[x])
plt.title(x + ' Outlier Detection')
plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")
#IQR
# which Coloumn
column = df[x]

# IQR
Q1 = column.quantile(0.25)
Q3 = column.quantile(0.75)
IQR = Q3 - Q1

# Bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# outliers
outliers = df[(column < lower_bound) | (column > upper_bound)]

print(outliers[['ID', 'LongName', x]])

"""column: SHO"""

x = 'SHO'

# boxplot
print("\nThis is BOX PLOT\n")
plt.boxplot(df[x])
plt.title(x + ' Outlier Detection')
plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")
#IQR
# which Coloumn
column = df[x]

# IQR
Q1 = column.quantile(0.25)
Q3 = column.quantile(0.75)
IQR = Q3 - Q1

# Bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# outliers
outliers = df[(column < lower_bound) | (column > upper_bound)]

print(outliers[['ID', 'LongName', x]])

"""column: PAS"""

x = 'PAS'

# boxplot
print("\nThis is BOX PLOT\n")
plt.boxplot(df[x])
plt.title(x + ' Outlier Detection')
plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")
#IQR
# which Coloumn
column = df[x]

# IQR
Q1 = column.quantile(0.25)
Q3 = column.quantile(0.75)
IQR = Q3 - Q1

# Bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# outliers
outliers = df[(column < lower_bound) | (column > upper_bound)]

print(outliers[['ID', 'LongName', x]])

"""column: DRI"""

x = 'DRI'

# boxplot
print("\nThis is BOX PLOT\n")
plt.boxplot(df[x])
plt.title(x + ' Outlier Detection')
plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")
#IQR
# which Coloumn
column = df[x]

# IQR
Q1 = column.quantile(0.25)
Q3 = column.quantile(0.75)
IQR = Q3 - Q1

# Bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# outliers
outliers = df[(column < lower_bound) | (column > upper_bound)]

print(outliers[['ID', 'LongName', x]])

"""column: DEF"""

x = 'DEF'

# boxplot
print("\nThis is BOX PLOT\n")
plt.boxplot(df[x])
plt.title(x + ' Outlier Detection')
plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")
#IQR
# which Coloumn
column = df[x]

# IQR
Q1 = column.quantile(0.25)
Q3 = column.quantile(0.75)
IQR = Q3 - Q1

# Bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# outliers
outliers = df[(column < lower_bound) | (column > upper_bound)]

print(outliers[['ID', 'LongName', x]])

"""column: PHY"""

x = 'PHY'

# boxplot
print("\nThis is BOX PLOT\n")
plt.boxplot(df[x])
plt.title(x + ' Outlier Detection')
plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

print("\nThis is IQR\n")
#IQR
# which Coloumn
column = df[x]

# IQR
Q1 = column.quantile(0.25)
Q3 = column.quantile(0.75)
IQR = Q3 - Q1

# Bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# outliers
outliers = df[(column < lower_bound) | (column > upper_bound)]

print(outliers[['ID', 'LongName', x]])

"""column: Hits"""

df['Hits'].dtype

x = 'Hits'

# boxplot
print("\nThis is BOX PLOT\n")
plt.boxplot(df[x])
plt.title(x + ' Outlier Detection')
plt.show()

#KDE
print("\nThis is KDE\n")
sns.kdeplot(df[x], fill=True)
plt.title(x+" Distribution")
plt.xlabel(x)
plt.ylabel("Density")
plt.show()

#KDE  LOG HITS
print("\nThis is KDE\n")
#  Hits log
df['Log_Hits'] = np.log1p(df['Hits'])  # log(x + 1)

# Log Hits
sns.kdeplot(df['Log_Hits'], fill=True)
plt.title('Log-Transformed Hits Distribution')
plt.xlabel('Log(Hits)')
plt.ylabel('Density')
plt.show()


print("\nThis is IQR\n")
#IQR
# which Coloumn
column = df[x]

# IQR
Q1 = column.quantile(0.25)
Q3 = column.quantile(0.75)
IQR = Q3 - Q1

# Bounds
lower_bound = Q1 - 3.0 * IQR
upper_bound = Q3 + 5.5 * IQR

# outliers
outliers = df[(column < lower_bound) | (column > upper_bound)]

print(outliers[['ID', 'LongName', x]])

"""---

##**Error Detection and Semantic Check （addtional check)**

Check if each player belongs to multiple clubs
"""

# Check if each player belongs to multiple clubs
duplicate_club_check = fifa.groupby('ID')['Club'].nunique()

# Find players belonging to multiple clubs
players_in_multiple_clubs = duplicate_club_check[duplicate_club_check > 1]

# Output the results
if not players_in_multiple_clubs.empty:
    print("Players belonging to multiple clubs:")
    print(players_in_multiple_clubs)
else:
    print("No players belong to multiple clubs.")

"""Check if there are conflicting club entries for the same player"""

# Check if there are conflicting club entries for the same player
conflict_check = fifa.groupby(['ID', 'Club']).size().reset_index(name='Counts')

# Find records where the same player is listed under different clubs
conflicting_entries = conflict_check[conflict_check['Counts'] > 1]

# Output the conflicting records
if not conflicting_entries.empty:
    print("Conflicting club information for the same player:")
    print(conflicting_entries)
else:
    print("No conflicting club information found.")

"""Check abnormal player counts Club"""

# Count the number of players in each club
club_player_counts = fifa['Club'].value_counts()

# Identify abnormal clubs (e.g., too few or too many players)
abnormal_clubs = club_player_counts[(club_player_counts < 10) | (club_player_counts > 50)]

# Output the results
if not abnormal_clubs.empty:
    print("Clubs with abnormal player counts:")
    print(abnormal_clubs)
else:
    print("All clubs have normal player counts.")

"""Check No Club Player's Wage, Value, Release Clause and Contract"""

# Filter out players who belong to "No Club"
no_club_players = fifa[fifa['Club'] == 'No Club']

# Check if contract dates are valid
invalid_contract_dates = no_club_players[
    (no_club_players['ContractStart'].notnull()) |
    (no_club_players['ContractEnd'].notnull())
]

# Check if Wage (€) is valid
# For "No Club" players, Wage (€) should be 0 or NaN
invalid_wage = no_club_players[
    (no_club_players['Wage(€)'] > 0) |
    (no_club_players['Wage(€)'].notnull())
]

# Check if ContractStatus is valid
# ContractStatus should be 'Free Agent' or 'Retired'
invalid_contract_status = no_club_players[
    ~no_club_players['ContractStatus'].isin(['Free'])
]

# Check if Value (k€) is valid
# For "No Club" players, Value (k€) should be 0 or NaN
invalid_value = no_club_players[
    (no_club_players['Value(k€)'] > 0) |
    (no_club_players['Value(k€)'].notnull())
]

# Check if Release Clause (k€) is valid
# For "No Club" players, Release Clause (k€) should be 0 or NaN
invalid_release_clause = no_club_players[
    (no_club_players['Release Clause(k€)'] > 0) |
    (no_club_players['Release Clause(k€)'].notnull())
]

# Print results
if not invalid_contract_dates.empty:
    print("No Club players with invalid contract dates (ID, Name, and Club):")
    print(invalid_contract_dates[['ID', 'Name', 'Club', 'ContractStart', 'ContractEnd']])
else:
    print("All No Club players have valid contract dates.")

if not invalid_wage.empty:
    print("No Club players with invalid wages (ID, Name, and Club):")
    print(invalid_wage[['ID', 'Name', 'Club', 'Wage(€)']])
else:
    print("All No Club players have valid wages.")

if not invalid_contract_status.empty:
    print("No Club players with invalid contract statuses (ID, Name, and Club):")
    print(invalid_contract_status[['ID', 'Name', 'Club', 'ContractStatus']])
else:
    print("All No Club players have valid contract statuses.")

if not invalid_value.empty:
    print("No Club players with invalid market values (ID, Name, and Club):")
    print(invalid_value[['ID', 'Name', 'Club', 'Value(k€)']])
else:
    print("All No Club players have valid market values.")

if not invalid_release_clause.empty:
    print("No Club players with invalid release clauses (ID, Name, and Club):")
    print(invalid_release_clause[['ID', 'Name', 'Club', 'Release Clause(k€)']])
else:
    print("All No Club players have valid release clauses.")

"""Check Contract"""

data_copy = fifa.copy()
print(data_copy.columns)

print(data_copy[['ID', 'Name', 'Club', 'Joined','ContractStart','ContractEnd','ContractStatus']])

# Check if ContractEnd is less than ContractStart
invalid_contract_dates = data_copy[
    (data_copy['ContractEnd'] < data_copy['ContractStart'])

]

# Display
if not invalid_contract_dates.empty:
    print("Players with ContractEnd not greater than ContractStart (ID, Name, Club, ContractStart, ContractEnd):")
    print(invalid_contract_dates[['ID', 'Name', 'Club', 'ContractStart', 'ContractEnd']])
else:
    print("All players have valid ContractStart and ContractEnd years.")

"""Check Stats"""

# Check Correctness of  Base Stats

# Calculate Sum of Base Stats
data_copy['Calculated Base Stats'] = (
    data_copy['PAC'] +
    data_copy['SHO'] +
    data_copy['PAS'] +
    data_copy['DRI'] +
    data_copy['DEF'] +
    data_copy['PHY']
)

# Find different records
invalid_base_stats = data_copy[data_copy['Base Stats'] != data_copy['Calculated Base Stats']]

# Display
if not invalid_base_stats.empty:
    print("Players with incorrect Base Stats (ID, Name, Club, Base Stats, Calculated Base Stats):")
    print(invalid_base_stats[['ID', 'Name', 'Club', 'Base Stats', 'Calculated Base Stats']])
else:
    print("All players have correct Base Stats.")

# Fill missing values with 0 to avoid calculation errors
data_copy[['Attacking', 'Skill', 'Movement', 'Power', 'Mentality', 'Defending', 'Goalkeeping']] = \
    data_copy[['Attacking', 'Skill', 'Movement', 'Power', 'Mentality', 'Defending', 'Goalkeeping']].fillna(0)

# Recalculate Total Stats based on the formula
data_copy['Calculated Total Stats'] = (
    data_copy['Attacking'] +
    data_copy['Skill'] +
    data_copy['Movement'] +
    data_copy['Power'] +
    data_copy['Mentality'] +
    data_copy['Defending'] +
    data_copy['Goalkeeping']
)

# Identify records where Total Stats do not match the calculated value
invalid_total_stats = data_copy[data_copy['Total Stats'] != data_copy['Calculated Total Stats']]

# Output the results
if not invalid_total_stats.empty:
    print("Players with incorrect Total Stats (ID, Name, Club, Total Stats, Calculated Total Stats):")
    print(invalid_total_stats[['ID', 'Name', 'Club', 'Total Stats', 'Calculated Total Stats']])
else:
    print("All players have correct Total Stats.")

"""##**Data Deduplication**"""

def cluster_by_fuzzy(names, threshold=80):
    """
    Idea:
        This function identifies clusters of similar strings in a list. It constructs an undirected graph
        where each node represents a string (club name), and edges connect any two nodes whose fuzzy similarity
        ratio is above a given threshold. Each connected component in this graph thus represents a cluster of
        mutually similar strings.

    Implementation Details:
        1. Index each string (node) from 0 to n-1.
        2. Build an adjacency list: for every pair of strings, if their fuzzy ratio >= threshold, connect them.
        3. Perform a depth-first search (DFS) to find connected components. Each component is one cluster of indices.
        4. Convert indices back to the original strings, forming a list of string clusters.

    :param names: A list of strings, e.g. ["FC Bayern München", "FC Bayern Munich", "Manchester City", ...].
    :param threshold: The similarity ratio threshold for connecting two strings (default is 80).
    :return: A list of clusters. Each cluster is a list of names that the algorithm deems similar.
    """

    n = len(names)
    adjacency_list = defaultdict(list)

    # Step 1: Compare every pair of strings. If their fuzzy ratio >= threshold, link them.
    for i in range(n):
        for j in range(i + 1, n):
            similarity = fuzz.ratio(names[i], names[j])
            if similarity >= threshold:
                adjacency_list[i].append(j)
                adjacency_list[j].append(i)

    # Step 2: Find connected components using DFS in the undirected graph.
    visited = set()
    clusters = []

    def dfs(node, component):
        visited.add(node)
        component.append(node)
        for neighbor in adjacency_list[node]:
            if neighbor not in visited:
                dfs(neighbor, component)

    # For each node that isn't visited yet, run DFS to find its connected component.
    for i in range(n):
        if i not in visited:
            component_indices = []
            dfs(i, component_indices)
            clusters.append(component_indices)

    # Step 3: Convert the node indices back to the actual strings.
    clusters_of_names = []
    for comp in clusters:
        cluster_names_list = [names[idx] for idx in comp]
        clusters_of_names.append(cluster_names_list)

    return clusters_of_names

"""column: Club"""

# Extract the unique club names from the "Club" column
club_names = (
    fifa["Club"]
    .unique()    # Get unique values
    .tolist()    # Convert to a Python list
)

# Cluster the club names by fuzzy similarity
groups = cluster_by_fuzzy(club_names, threshold=80)

# Print out the resulting groups
for i, group in enumerate(groups, 1):
    print(f"Group {i}: {group}")

"""column: Nationality"""

# Extract the unique nationalities from the "Nationality" column
nat_names = (
    fifa["Nationality"]
    .dropna()    # Remove any NaN/empty values
    .unique()    # Get unique values
    .tolist()    # Convert to a Python list
)

# Cluster the nationalities by fuzzy similarity
groups_nat = cluster_by_fuzzy(nat_names, threshold=80)

# Print out the resulting groups
for i, group in enumerate(groups_nat, 1):
    print(f"Group {i}: {group}")

"""Exact Matching"""

fifa = fifa.drop_duplicates() #dropped the exact matching
fifa

"""Not-Exact Matching"""

# Create an indexer using the Sorted Neighbourhood method.
# This method helps in identifying and linking records that refer to the same entity across different datasets.
indexer = recordlinkage.index.SortedNeighbourhood(
        on='Club',  # Specifies the column based on which the sorting and windowing are to be performed.
        window=9   # The window size determines how many adjacent records in the sorted list will be compared to each other.
)

# Apply the indexer to the 'fifa' DataFrame.
# This method will sort the dataframe by the 'Club' column and then slide a window of size 9 over these sorted values.
# Each record in the window is considered a potential match with each other.
candidate_links = indexer.index(fifa)

# 'candidate_links' now contains pairs of indices from 'fifa' DataFrame that are considered as potential matches.
# These can later be scored and evaluated to confirm actual matches.
candidate_links

fifa.columns

# Initialize a Compare object to define the comparison operations between record pairs.
compare_cl = recordlinkage.Compare()

# Add exact comparison methods for various fields where the records must match exactly.
compare_cl.exact('Club', 'Club', label='Club')  # Compare 'Club' fields exactly.
compare_cl.exact('Age', 'Age', label='Age')  # Compare 'Age' fields exactly.
compare_cl.exact('Height(cm)', 'Height(cm)', label='Height(cm)')  # Compare 'Height' fields exactly.
compare_cl.exact('Weight(kg)', 'Weight(kg)', label='Weight(kg)')  # Compare 'Weight' fields exactly.
compare_cl.exact('Nationality', 'Nationality', label='Nationality')  # Compare 'Nationality' fields exactly.

# Add a string comparison for 'LongName' fields using the Jaro-Winkler similarity method.
# Records are considered a match if the similarity score is 0.95 or above.
compare_cl.string('LongName', 'LongName', method='jarowinkler', threshold=0.95, label='LongName')

# Compute the comparison features over all candidate pairs.
# This will perform all the above comparisons for each record pair in 'candidate_links'.
features = compare_cl.compute(candidate_links, fifa)

# Filter matches where the sum of comparison scores is greater than 5.
# This typically means that multiple fields have matched exactly or very closely, indicating a high likelihood of a true match.
matches = features[features.sum(axis=1) > 5]

matches

matches.index

# Assuming 'matches' is a DataFrame containing indices of matching record pairs from the 'fifa' DataFrame
# 'matches.index' contains tuples of indices indicating matched pairs
for i in matches.index:
    # Print the details of the records from the 'fifa' DataFrame that are considered matches
    # 'i[0]' and 'i[1]' are the indices of the matched pair in the original 'fifa' DataFrame
    print(fifa.iloc[[i[0], i[1]]])

"""# **4. Final Data Assessment**"""

def print_colored(value, condition):
    if condition:
        print(f"\033[91m{value}\033[0m")  # red
    else:
        print(value)  # black

for col in fifa.columns:
    COUNT = fifa[col].count()
    DISTINCT = fifa[col].nunique()
    ROWS = len(fifa[col])

    NULL = fifa[col].isnull().sum()
    Missing = (fifa[col] == '').sum()

    Actual = fifa[col].dropna()[fifa[col] != ''].count()         # total        non null and non missing value in the row
    Cardinality = fifa[col].dropna()[fifa[col] != ''].nunique()  # total unique non null and non missing value in the row

    UNIQUENESS = Cardinality / ROWS                              # percentage of unique value in the row
    DISTINCTNESS = Cardinality / Actual if Actual else 0         # percentage of unique value in the actual value of row

    Completeness = Actual / ROWS if ROWS else 0                  # percentage of non-NULL value in the row

    print(f"DQ Assessment for {col}:")
    print_colored(f"NULL: {NULL}", NULL != 0)
    print_colored(f"Missing: {Missing}", Missing > 0)
    print_colored(f"Actual: {Actual}", Actual < ROWS)
    print_colored(f"Completeness: {Completeness:.12f}", Completeness != 1)
    print(f"Cardinality: {Cardinality}")
    print(f"Uniqueness: {UNIQUENESS:.12f}")
    print_colored(f"Distinctness: {DISTINCTNESS:.12f}", DISTINCTNESS < UNIQUENESS)
    print("\n")

NUM = list(fifa.select_dtypes(include=['int64','float64']).columns)
fifa_NUM = fifa[NUM]
fifa_NUM.corr(method ='pearson')

corr = fifa_NUM.corr(method ='pearson')
sns.heatmap(corr)
plt.show()



"""Using **YDATA-PROFILING LIBRARY** for data profiling"""



PROFILE = ProfileReport(fifa, title="Pandas Profiling Report")
PROFILE

"""# **5. Prepare cleaned Dataset**"""

file_path = 'fifa_cleaned.csv'
fifa.to_csv(file_path, index=False)

print(f"DataFrame has been saved to {file_path}")